1. Instalamos Express -> lo importamos en el index
2. Instalamos Eslint
3. Iniciamos Eslint -> `npm init @eslint/config`
4. Instalamos Mongodb -> generamos un archivo para configurarlo
5. INstalamos mongoose y nodemon
6. Instalamos cors, dotenv, (mongoose-unique-validator, jsonwebtoken)
7. Creamos el archivo .env

!!ACORDARSE DE AÑADIRLO A .GITIGNORE junto con los NODE_MODULES!!

8. Index.js -> creamos el export const app = express()
9. Inicializamos el primer get con app.get('/', (request, response)=>{
	response.send('<h1>Hello World!<h1>')
})
10. Se configuran los scripts para levantarlo. El primero suele ser start con nodemon index.js sustituyendo a node para que se refresque automáticamente.

11. Si creamos un archivo llamado mongo y lo importamos solo con import 'mongo.js' hay que configurarlo para que nos lo levante, actualmente tenemos todo cerrado. Para ello hay que configurar los .env. El puerto es lo primero: PORT
export const server = app.listen(process.env.PORT, ()=> {
	console.log(`Server running on port ${process.env.PORT}`)
})
Si no funciona es porque tienes que seguir configurando tu archivo mongo.js para inicializarlo. solo tienes que darle la interpretación del dotenv en mogno para que entienda cómo funciona proces.env.PORT

12. Usamos mongoose.connect(URI).then(databaseconected).catch(error) para conectarnos y que nos muestre un console log exitoso o un error en caso de inconnexión.
13. Añadimos un process.on('uncaughtException', (err)=>{console.error(err) mongoose.disconnect()}) para que si hay algún error con al URI se cierre mongoose y así no permanezca el servidor conectado.

14. Como nos piden un modelo de User necesitamos gestionar esa api. Asíque creamos el get de los usuarios acordándonos de usar await User.find() y response.json(users)
15. Como el modelo no está creado lo creamos User.js. Utilizamos mongooseUniqueValidator habiéndolo instalado para que nos permita tener elementos unicos en la DB